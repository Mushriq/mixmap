#' Plot top contributions (internal function)
#'
#' This function generates a plot of the top contributing features for the top n models.
#' @keywords plot
#' @import ggplot2 cowplot purrr
#' @examples
#' plot_top_contributors(shap_table, name, 10)
helper_plot_top_contributors <- function(shap_table, name, n, color = "#52565e"){
  
  shap_table <- shap_table %>% top_n(n, wt=value)
  shap_table$term <- factor(str_to_upper(shap_table$term), levels = rev(str_to_upper(shap_table$term)))
  shap_table$labels <- abbreviate(as.character(shap_table$term), minlength = 10, dot = T)
  p <- ggplot(shap_table, aes(x=term,y=value))+geom_bar(stat="identity", fill = color)+coord_flip()+
    labs(x="Feature",y="Contribution",subtitle=str_to_upper(word(name,2,sep="_")))+
    scale_x_discrete(labels = shap_table$labels)
  
  return(p)
  
}

#' Plot top contributions
#'
#' This function generates a plot of the top contributing features for the top n models.
#' @param models A list of model objects generated by make_xgb_models
#' @param models_to_use A vector of model names to restrict the plot to.
#' @param data_to_use If "training" (default), it will use the full training data. If anything else, it will use the new predictions (must have used add_predictions before).
#' @param n_predictors The maximum number of predictors to show per plot.
#' @param n_columns If multiple models are being plotted, how many columns in the plot grid to use.
#' @param color The color of the bars in the plot.
#' @keywords plot
#' @import ggplot2 cowplot purrr
#' @export
#' @examples
#' plot_top_contributors(shap_table, name, 10)
plot_top_contributors <- function(models, models_to_use = NULL, data_to_use = "training", n_predictors = 10, n_columns = 5, color = "#52565e"){
  
  # Restrict the plot to the top 10 most variable predictions across our clusters
  models_of_interest <- models
  if(!is.null(models_to_use) && length(models_to_use) > 0){
    models_of_interest <- models[models_to_use]
  }
  
  if (data_to_use == "training"){
    shap_tables <- map(models_of_interest, "feature_contribution")
  } else {
    shap_tables <- map(models_of_interest, "new_data") %>% map("feature_contribution")
  }

  p <- plot_grid(plotlist = imap(shap_tables, helper_plot_top_contributors, n = n_predictors, color = color), align='v', ncol=n_columns)

  return(p)
  
}


#' Overlay predictions on a dimensional reduction plot
#'
#' This function generates a dimensional reduction plot with predictions overlayed on each cell.
#' @param scRNA_data A Seurat object with predictions appended (e.g. using append_predictions_to_seurat)
#' @param perturbation The name of the perturbation whose predictions we want to plot.
#' @param reduction The dimensionality reduction technique to show (default = 'umap')
#' @param dims A 2-element vector with the dimensions to plot (default = c(1,2))
#' @param fixed_color_scale Default = FALSE. If TRUE, the color scale will be fixed from 0 to 1.
#' @keywords plot dimplot
#' @import Seurat ggplot2 cowplot
#' @export
#' @examples
#' plot_predictions_dimplot(my_seurat_obj, "ko_ctnnb1")
plot_predictions_dimplot <- function(scRNA_data, perturbation, 
                                     reduction = "umap",
                                     dims = c(1,2),
                                     fixed_color_scale = FALSE){
  
  feature_data <- scRNA_data@meta.data[,perturbation]
  embed_data <- scRNA_data[[reduction]]@cell.embeddings
  dim_1 <- embed_data[,dims[1]]
  dim_2 <- embed_data[,dims[2]]
  
  plot_data <- embed_data %>% cbind(feature_data)
  
  
  p <- ggplot()+
    geom_point(aes(x=dim_1,y=dim_2,color=feature_data))
  
  if(fixed_color_scale){
    p <- p + scale_color_distiller(palette = "RdYlBu", direction = -1, limits = c(0, 1))
  } else {
    p <- p + scale_color_distiller(palette = "RdYlBu", direction = -1)
  }
  
  
  p <- p + theme_bw(base_line_size = 0)+
    labs(color = perturbation, x = colnames(embed_data)[dims[1]], y = colnames(embed_data)[dims[2]])
  
  return(p)
  
}



#' Plot feature contributions to sample predictions
#'
#' This function plots the contribution (Shapley values) of the top features to a sample's predictions.
#' @param model A model generated with make_xgb_models and has appended predictions with add_predictions.
#' @param model_data The training dataset used to generate the model.
#' @param name The name of the perturbation whose prediction we want to plot.
#' @param sample_names The names of the samples we want to generate a plot for.
#' @param n_features The number of top contributors to show their individual contribution. All other predictors will have their contribution combined.
#' @param n_columns Number of columns to plot in a grid when plotting more than one sample.
#' @param short_title If using many columns, set to TRUE to shorten the title of the plot.
#' @param fixed_axis If TRUE, the plot will be set to a fixed scale (-0.05 to 1). Default = FALSE.
#' @param replace_names If TRUE, the sample name will be replaced using get_cell_line_name. Must supply sample_info.
#' @param sample_info If replace_names is TRUE, this must be supplied.
#' @param show_error If TRUE, a shaded area will be used to visualize prediction interval. Default = TRUE.
#' @param highlight_significant If TRUE, a border will be shown to indicate the prediction interval is above 0.5. Default = FALSE.
#' @param plot_new_data Set to TRUE if plotting the contribution to a new sample (not used in training).
#' @keywords plot shapley contribution
#' @import Seurat ggplot2 cowplot data.table
#' @export
#' @examples
#' plot_contribution_to_sample(my_models, model_dataset, "ko_ctnnb1", "my_sample")
plot_contribution_to_sample <- function(model, model_data, name, sample_names, 
                                        n_features = 5, 
                                        n_columns = 1,
                                        short_title = FALSE,
                                        fixed_axis = FALSE, 
                                        replace_names = FALSE,  sample_info = NULL,
                                        show_error = TRUE, 
                                        highlight_significant = FALSE,
                                        plot_new_data = FALSE){
  
  # This will hold the final list of plots
  p_list <- list()
  
  # The null prediction is just the average of all predictions in the training data
  
  null_prediction = model$null_prediction #  mean(model$predictions)
  
  feature_data <- get_original_data(model,model_data)
  
  for (sample_name in sample_names){
    
    
    # We store the final prediction value
    if(!plot_new_data) final_prediction = model$predictions[sample_name] else final_prediction = model$new_data$predictions[sample_name]
    
    # Estimate error
    if(!plot_new_data) prediction_error <- model$predictions_error[sample_name] else prediction_error <- model$new_data$predictions_error[sample_name]
    error_upper <- final_prediction + 1.96*prediction_error
    error_lower <- final_prediction - 1.96*prediction_error
    
    
    # Create a long table of terms and their shapley values (called shap_value)
    if(!plot_new_data) term_values <- model$shap_values[sample_name,] else term_values <- model$new_data$shap_values[sample_name,] 
    
    term_values <- term_values %>% data.table::transpose(keep.names = "term") %>% 
      rename("shap_value" = "V1") %>% arrange(desc(abs(shap_value))) %>% filter(abs(shap_value) > 0)
    
    
    
    # Add the expression level of each term (called feature_value)
    if(!plot_new_data){
      feature_values <- feature_data[sample_name,]
    } else {
      feature_values <- model$new_data$data[sample_name,]
    }
    
    
    feature_values <- feature_values %>% t %>% as_tibble(rownames = "term")
    colnames(feature_values) <- c("term","feature_value")
    feature_values <- feature_values %>% mutate(feature_value = round(feature_value, 2))
    term_values <- term_values %>% left_join(feature_values, by = "term")
    
    
    # Keep the top terms, and combine the contribution of all other terms (we also count how many terms we combined)
    top_terms <- term_values %>% top_n(n_features, wt=abs(shap_value)) %>% pull(term)
    other_count <- term_values %>% filter(!term %in% top_terms) %>% pull(shap_value) %>% length()
    other_sum <- term_values %>% filter(!term %in% top_terms) %>% pull(shap_value) %>% sum()
    if (other_count == 1) term_word = "term" else term_word = "terms"
    other_row <- tibble(term = glue::glue("{other_count} other {term_word}"), shap_value = other_sum)
    none_row <- tibble(term = glue::glue("starting_value"), shap_value = null_prediction)
    
    # We generate all the information we need to make the plot
    term_values <- term_values %>% filter(term %in% top_terms) %>% bind_rows(other_row) %>% bind_rows(none_row) %>%
      rowid_to_column("id") %>% arrange(desc(id)) %>% 
      mutate(end = cumsum(shap_value)) %>% mutate(start = lag(end, default = 0)) %>%
      filter(term != "starting_value") %>%
      mutate(term = factor(term, levels=term)) %>% mutate(id = seq_along(term)) %>%
      mutate(term_label = if_else(!is.na(feature_value),glue::glue("{str_to_upper(term)} = {feature_value}"),str_to_upper(term))) %>%
      mutate(term_label = factor(term_label, levels=term_label)) %>%
      mutate(term_direction = if_else(shap_value > 0, "positive", "negative"))
    
    
    
    clean_perturb_name = str_to_upper(word(name, 2, sep="_"))
    
    if(replace_names & !plot_new_data) sample_name <- get_cell_line_name(sample_name, sample_info)
    
    # Make the plot    
    p <- ggplot(term_values, aes(x = term_label, fill = term_direction)) + 
      geom_point(alpha=0, y=0)+
      geom_hline(yintercept = first(term_values$start), linetype = "dashed", color = "lightgray")+
      geom_hline(yintercept = last(term_values$end), linetype = "dashed", color = "black")
    
    
    if (show_error){
      p <- p +
        geom_rect(xmin = -Inf, xmax = Inf, ymin = last(term_values$end) - 1.96*prediction_error, ymax = last(term_values$end) + 1.96*prediction_error, alpha = 0.025, fill="gray")+
        geom_hline(yintercept = last(term_values$end) + 1.96*prediction_error, linetype = "dashed", color = "lightgray")+
        geom_hline(yintercept = last(term_values$end) - 1.96*prediction_error, linetype = "dashed", color = "lightgray")
      
      
    } 
    
    plot_title = glue::glue("{sample_name} ({scales::percent(final_prediction,accuracy = 1)} probability of {clean_perturb_name} dependency)")
    
    if(short_title)  plot_title = glue::glue("{sample_name} ({scales::percent(final_prediction,accuracy = 1)} {clean_perturb_name})")
    
    p <- p + geom_rect(aes(xmin = id - 0.45, xmax = id + 0.45, ymin = start, ymax = end))+
      geom_segment(aes(x = id, xend = id, y = start, yend = end), lineend = "round", linejoin ="round", size = 0.7, arrow = arrow(angle = 30, length = unit(0.5, "cm")), color = "white")+
      geom_text(aes(x = id,
                    y = end, 
                    color = if_else(shap_value > 0, "positive","negative"), 
                    label = if_else(shap_value > 0, paste0("+",scales::percent(shap_value,accuracy=0.01)),scales::percent(shap_value,accuracy=0.01))), 
                nudge_y = if_else(term_values$shap_value > 0, 0.04, -0.04),
                size = 3, hjust = 0.5)+
      scale_color_manual(values = c("negative" = "#3591d1", "positive" = "#f04546"))+
      scale_fill_manual(values = c("negative" = "#3591d1", "positive" = "#f04546"))+
      labs(subtitle = plot_title,
           x = NULL, y = "Feature Contribution")+
      theme_bw()+
      theme(text=element_text(size=14), legend.position="none")
    
    if (!fixed_axis) p <- p+coord_flip(ylim = c(min(c(term_values$start, term_values$end))-0.05,0.05+max(c(term_values$start, term_values$end))))
    else p <- p+coord_flip(ylim = c(-0.05,1))+scale_y_continuous(labels = scales::percent)
    
    if (highlight_significant && error_lower >= 0.5) p <- p +  theme(panel.border = element_rect(color = "red", fill = NA, size = 1))
    
    p_list[[sample_name]] <- p
    
  }
  
  p_final <- plot_grid(plotlist = p_list, ncol=n_columns, align='v')
  
  return(p_final)
  
}


#' Plot feature contributions to sample predictions from the training set.
#'
#' This function plots the contribution (Shapley values) of the top features to a sample's predictions.
#' @param models A list of models generated with make_xgb_models and has appended predictions with add_predictions.
#' @param models_to_use A vector of model names to plot.
#' @param model_data The training dataset used to generate the model.
#' @param n_features The number of top contributors to show their individual contribution. All other predictors will have their contribution combined.
#' @param n_columns Number of columns to plot in a grid when plotting more than one sample.
#' @param short_title If using many columns, set to TRUE to shorten the title of the plot.
#' @param fixed_axis If TRUE, the plot will be set to a fixed scale (-0.05 to 1). Default = FALSE.
#' @param replace_names If TRUE, the sample name will be replaced using get_cell_line_name. Must supply sample_info.
#' @param sample_info If replace_names is TRUE, this must be supplied.
#' @param show_error If TRUE, a shaded area will be used to visualize prediction interval. Default = TRUE.
#' @keywords plot shapley contribution
#' @import Seurat ggplot2 cowplot data.table
#' @export
#' @examples
#' plot_contribution_to_training_sample(my_models, c("ko_ctnnb1","ko_myod1"), model_dataset, lineage_to_use = "soft_tissue")
plot_contribution_to_training_sample <- function(models, models_to_use, model_data, 
                                             samples_to_use = NULL, lineage_to_use = NULL, 
                                             n_features = 5, n_columns = 1, fixed_axis = TRUE, show_error = TRUE,
                                             highlight_significant = FALSE,
                                             replace_names = FALSE, sample_info = NULL){
  
  
  # Restrict the list of models to only those we wish to plot
  demo_models <- models[models_to_use]
  
  # Restrict the sample list to only those we wish to plot
  samples_to_plot <- map(demo_models, get_demo_samples, samples = samples_to_use, lineage = lineage_to_use, model_data = model_data)

  # Generate a list of inputs
  inputs <- list()
  inputs$model <- demo_models
  inputs$name <- names(demo_models)
  inputs$sample_names <- samples_to_plot
  
  # Iterate through each input and add the plot to the list
  pl <- pmap(inputs, plot_contribution_to_sample, model_data = model_data, 
             n_features = n_features, n_columns = n_columns, fixed_axis = fixed_axis, 
             replace_names = replace_names, sample_info = sample_info, 
             highlight_significant = highlight_significant,
             show_error = show_error)
  
  return(pl)
}





#' Plot feature contributions to new sample predictions
#'
#' This function plots the contribution (Shapley values) of the top features to a sample's predictions, using new samples.
#' @param models A list of models generated with make_xgb_models and has appended predictions with add_predictions.
#' @param models_to_use A vector of model names to plot.
#' @param model_data The training dataset used to generate the model.
#' @param n_features The number of top contributors to show their individual contribution. All other predictors will have their contribution combined.
#' @param n_columns Number of columns to plot in a grid when plotting more than one sample.
#' @param short_title If using many columns, set to TRUE to shorten the title of the plot.
#' @param fixed_axis If TRUE, the plot will be set to a fixed scale (-0.05 to 1). Default = FALSE.
#' @param replace_names If TRUE, the sample name will be replaced using get_cell_line_name. Must supply sample_info.
#' @param sample_info If replace_names is TRUE, this must be supplied.
#' @param show_error If TRUE, a shaded area will be used to visualize prediction interval. Default = TRUE.
#' @keywords plot shapley contribution
#' @import Seurat ggplot2 cowplot data.table
#' @export
#' @examples
#' plot_contribution_to_sample_demo(my_models, c("ko_ctnnb1","ko_myod1"), model_dataset, "soft_tissue")
plot_contribution_to_new_samples <- function(models, models_to_use, model_data, 
                                             new_samples_to_use = NULL,
                                             n_features = 5, n_columns = 4, fixed_axis = TRUE, show_error = TRUE,
                                             highlight_significant = TRUE, short_title = TRUE, sample_info = NULL){
  
  # Restrict the list of models to only those we wish to plot
  demo_models <- models[models_to_use]
  
  # Restrict the sample list to only those we wish to plot
  samples_to_plot <- map(my_models_with_predictions[example_perturbation], "new_data") %>% 
    map("data") %>% 
    map(rownames)
  
  if(!is.null(new_samples_to_use) && length(new_samples_to_use) > 0) samples_to_plot <- samples_to_plot %>% map(intersect, new_samples_to_use)
  
  # Generate a list of inputs
  inputs <- list()
  inputs$model <- demo_models
  inputs$name <- names(demo_models)
  inputs$sample_names <- samples_to_plot
  
  # Iterate through each input and add the plot to the list
  pl <- pmap(inputs, plot_contribution_to_sample, model_data = model_data, 
             n_features = n_features, n_columns = n_columns, fixed_axis = fixed_axis, 
             replace_names = FALSE, sample_info = sample_info, 
             highlight_significant = highlight_significant, short_title = short_title,
             show_error = show_error, plot_new_data = TRUE) 
  
  return(pl)
  
}


  

